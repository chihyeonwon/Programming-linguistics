## 버퍼 오버플로우 메모리 관련 복습

# Programming-linguistics
컴퓨터공학과 프로그래밍 언어론 정리입니다.
## 종강
![image](https://github.com/mr-won/Programming-linguistics/assets/58906858/3eab74ee-9f65-42aa-b849-4a79e8a445be)
```
컴퓨터 프로그래밍 언어를 설계하고 구현하는 방법과 현대 컴퓨터 프로그래밍 언어가 가지고 있는 주요
요소들 및 패러다임에 따른 장단점들을 배울 수 있었습니다.
```
[BNF](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hamill_a&logNo=221125554113)
[4](https://blog.naver.com/PostView.nhn?blogId=bh5kks&logNo=220498445612)
![image](https://github.com/wonchihyeon/Programming-linguistics/assets/58906858/532d1fb1-1f40-4e6c-957d-fd56aa0d6d9b)
![image](https://github.com/wonchihyeon/Programming-linguistics/assets/58906858/be821b10-a10b-407c-aee6-3578397112e9)
```
assign은 변화가능한 variable expression으로 유도가 가능하다.
LHS 정의하려는 추상화 : RHS는 토큰, 어휘항목, 다른 추상화에 대한 참조로 구성

논터미널 기호 혹은 논터미널 : 추상화된 대상
터미널 기호 혹은 터미널 : 규칙에 포함된 어휘항목과 토큰
논터미널 기호는 두 개 이상의 다른 정의를 가질 수 있음

리스트 명세 가변 길이의 리스트를 표현할 때 BNF에서는 재귀를 사용

최좌단 유도 -> 파스트리 -> 파스트리 구축 -> 유도 o 문제 x

문법의 모호성을 제거하는 방법 : 연산자의 우선순위, 연산의 결합 규칙

연산자 우선순위가 있고 없고의 차이가 있다.
연산자 우선순위는 낮은쪽에서부터 계산된다.
낮은 쪽이 먼저 생성되므로 연산자 우선 순위에 따라서 연산을 수행하므로 모호성을 제거한다.
(깊이 우선)

연산의 결합규칙
좌결합규칙: 좌순환적 표현은 좌결합 규칙을 기술한다. RHS의 시작 위치에 LHS가 나타나는 경우
우결합규칙: LHS가 RHS의 오른쪽 끝에 나타나는 경우
좌측의 <factor>가 우측에도 나타난다.<factor>

if then else를 위한 모호하지 않은 문법 else의 위치가 어디에 있을까

Dangling else 문제 if if else < 아무것도 출력이 안된다. 
if else if < 출력

if if else if statment?

BNF보다 서술 능력이 향상된 것은 아니며 단지 가독성과 작성력만 향상

<> 가 있는 건 논 터미널
-> 유도
<program> -> begin <> end -> <>
A = B + C; <- 터미널   

최좌단 유도 논미널 <> -> 터미널로 유도

구조상 파스트리와 같다.
중간 노드는 논터미널
잎 노드는 터미널
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/77c1ed68-fa4d-47b6-97e1-eed7d43b081c)

```
문법의 모호성 ? -> 주어진 한 문장에 대해 두 개 이상의 다른 파스트리를 생성할 경우
컴파일러가 의미를 결정할 수 없기 때문에

모호할 경우 해결책 -> 문법의 재작성, 비문법적 정보를 제공하여 하나의 올바른 파스트리를 구성

해결책으로 연산자 우선순위를 도입

낮은 곳이 먼저 계산된다. 우선순위가 높은 것을 파스트리의 최하단에 위치하게 함

if else -> 두 개의 파스트리(모호하다)

else 규칙 : 이전에 매칭되지 않은 가까운 then 에 매칭이 된다.
<match>, <unmatch> 나누어서 작성


yacc 구문 생성기가 parse 구문 분석기를 생성한다.

c,c++ 컴파일러
java 인터프리터

어휘분석과 구문 분석과 분리하는 이유

어휘분석(토큰과 렉심으로 구분) 토큰화 토큰, lexeme가 의미 -> 심볼 쌍을 이룬다.

어휘분석기의 역할 -> 주석제거, 심볼 테이블 구축, 어휘 에러 탐지 및 통보

어휘분석기 -> lex 정규 표현식을 사용한 lex, 패턴을 정의하는 상태 전이도, 상태전이도에 대한 테이블 구동 구현을 직접 구성

유한 오토마타 -> 유향 그래프

. 의미를 박탈해라 영문자가 여러개 오고 숫자가 오면 id다
스페이스 -> 뛰어넘어라

구문 분석의 목적 (파서의 역할)

파스트리를 구축

하향식-> 위에서 아래로 최좌단 유도와 같은 순서 LL 파서, 재귀 하향 파싱
상향식-> 아래에서 위로 최우단 유도의 역순 LL 파서, 이동-감축 알고리즘 yacc

파싱 알고리즘 복잡도 O(n^3) 소스코드에 비례
상업적 파서의 복잡도를 O(n)으로 줄임

최좌단,우단이던 파스트리는 하나만 생성

하향식 <- 재귀 하향 파싱 , 전역 변수 nextToken 파싱할 때 다음 토큰을 미리본다. LL 문법
좌측에서 1개의 터미널
하향식 <- LL , 재귀

expr term factor ( expr term factor sum expr + expr term factor 47 - 최종적으로 expr 다시

직접 좌순환 <- 재귀호출로 인한 스택오버플로우 발생
간접 좌순환 <- A -> BaA A가 즉시 자신을 호출하는 부분이 발생

하향식 순환을 안쓰는 데에는 이유가 있다.

상향식 순환을 자주 사용한다.

집합쌍 불일치 테스트
nextToken(lookahead)이 하나여야하는데 여러 경우면 안된다. 여러 경우면 RHS를 선택할 수 없다.

A 논터미널 a터미널 first의 집합의(a, b, c, d) 교집합이 공집합이므로(disjoin)하므로
하향식 파싱이 가능하다.

first가 a, a, b 서로 disjoint 하지 않으므로 하향식 파싱이 불가능하다.
```
[스택과 힙](https://blog.naver.com/gothevole/223232263442)
```
스택 : 지역변수, 함수 호출(지역변수,리턴되는 주소, 파라미터), 컴파일러
힙 : 동적으로 할당, 프로그래머가 관리

extern 전역변수 -> Data영역
실행->로더가 프로그램을 올려준다. 메모리 상에 코드부분은 코드부분
데이터는 데이터부분, stack, heap

code, data, stack, heap
os

스택에는 main부터 쌓음
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/b62c5f2e-11e9-4ffa-9804-76bed8b281ca)
```
상향식 파싱 최우단 유도의 역순

입력은 shift 토큰 스트림
출력은 발견된 문법 규칙

shift - Reduce 알고리즘

푸시다운 오토마타 문법에대한 인식
모든 파서는 푸시다운 오토마타
재귀 하강 파서도 푸시다운 오토마타

LR 파서의 장점, 단점을 서술하라

LR파서는 상대적으로 작은 파서코드와 파싱테이블로 구성
LR파서는 LL파서로 처리가능한 문법을 모두 처리 가능하다
LR파서는 적은 파서코드로도 LL파서로 처리가능한 문법을 모두 처리 가능하다.

단점 : 파싱테이블을 수작업으로 구축하기가 어렵다.
문법을 입력받아서 파싱테이블을 자동으로 생성하는 Yacc 프로그램이 존재한다.

0id5 스택 0, (id, 5) -> 0,(F,3) -> 0,(T,2)

중간고사 시험

LR 파싱테이블 ACTION이 어떻게 일어날까 
하향식 파서 처리부분

변수(타입 주소 값, 바인딩, 바인딩 시간)
영역(scope, lifetime)
초기화

폰노이만의 컴퓨터 추상화 데이터를 저장과 데이터 가공을 위한 연산으로 구성
메모리 셀에 대한 추상화 -> 변수, 배열 등 

```
### 반대로
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/e0a85559-4484-496d-8cc6-b0eef9320d3c)
```
0 <- 스택에
5 <- R6 Reduce6 id가 f가되고 상태를 변화 감축되고 난 후에 상태 변화
0F3 상태가 0에서 3이됨
3, + -> R4

1, + S6

문법을 반대로

0 E 1 4 6 T 1 8 7 f 10

t * f -> t

0 E 1 4 6 T 10

6,T -> 9

0 E 1 4 6 T 9

E+T -> E

0 E -> 1

0 E 1
```

```
변수의 속성(타입, 주소, 값)이 설정되는 시점이 다 다르다.
변수의 속성이 설정되는 시점이 바인딩 시간

변수는 영역, 존속 기간이 있다.

변수(타입, 주소, 값, 영역, 존속기간)

예외를 허용하지 않는 순수 함수형 언어에서의 변수는 값의 변경을 허용하지 않는다.

이름 case sensitive 대소문자구별

특수어 : if, for, while 프로그래밍 언어에서 수행할 행동들을 명칭화한 것.
예약어 : 특수어는 예약어로 분류, 특별한 의미로 해석하도록 선정이 되어있는 것.
키워드 : integer, float같은 자료형 처럼 어떤 문맥에서만 특별하게 사용되는 단어.

함수에서 자기 자신을 호출하는 경우 지역변수, 매개변수, 리턴값이 메모리의 영역을 벗어나는
세그먼테이션 오류가 발생한다.

스택변수 : 동일한 변수가 다른 시점에 다른 주소와 연관되는 것이 가능
L-value : 배정문의 좌측에 위치 값의 좌측에 놓인다. x = 3 (x는 변수, 좌측)

포인터 -> 별칭인데 가독성을 떨어뜨리는 요소가 된다.

x = x + 3

L-value -> x의 주소
R-value -> x + 3 -> x의 내용에 3 더하고 x의 주소에 넣어라

스택,데이터 영역 -> 이름있는 변수
힙 -> 이름없는변수

변수는 이름이 있을수도 있고 없을 수도 있다.

타입 : 변수가 저장할 수 있는 값들의 범위와 연산들의 집합을 결정

바인딩 : 속성과 개체간의 연관

언어 설계 시간 design : * 곱셈기호(포인터)
언어 구현 implementation 시간 C언어의 int type 1워드<-레지스터크기에 따라 다름 사이즈

edit time = desigin + implementation

컴파일 시간 : c, java 변수와 타입

링크 시간

로딩 시간 : 전역변수와 그의 주소
실행 시간 : 지역 변수와 그의 주소(main함수에서 콜이된 다음 설정)

자바에서 값의 사이즈가 설계 시간에 바딩 < 자바는 자바 virtual machine 설계 시간때 값의 범위 결정

실매개변수와 형식 매개변수 간의 바인딩이 어떻게 일어나는가 <- 실행 단계

실행단계 전에서 바인딩된다. 정적바인딩
실행 시간 중이거나 실행 과정에서 바인딩이 변경 될 수 있는 경우 -> 동적바인딩

하드웨어 바인딩은 고려하지 않음
os가 개입하는 가상메모리와 실메모리사이의 매핑(바인딩)은 고려 x

정적 타입 바인딩 <- 컴파일 시에 변수의 타입이 결정 됨
명시적 선언 : 컴파일러 방식, 변수 이름들을 나열하고 타입을 명세
묵시적 선언 : 컴파일러 방식이나 인터프리터 방식

명시적인것이 묵시적인것보다 좋다

타입 추론 var <- 실행시간이 아닌 컴파일 시간에 결정

동적 타입 바인딩 <- 변수의 타입이 명세 x 순수 인터프리터 언어 파이썬, 자스, c#
```
## 23.11.03

```
존속기간 = 기억장소에서 할당되고 회수되기 까지의 시간 (시간적인 개념)

정적 변수 <- 전역 변수, 정적 지역 변수에 해당. static 지정자는 클래스 변수를 생성
->장점 : 어디에서나 존재하므로 프로그램의 어느 부분에서나 직접적 접근이 가능
할당과 회수를 위한 부담이 없다. 할당하고 회수는 한 번만 이루어짐

->단점 : 유연성이 감소한다. 재귀적 호출x 스택을 이용하지 못하기 때문에

스택- 동적 변수 : 실행될 때 기억 공간에 바인딩 타입은 정적이지만 공간만 동적 바인딩되고 나머지 속성은 정적 바인딩
c함수, java 메서드의 지역변수, 매개 변수,
-> 장점 : 각 부프로그램 마다 자신의 기억 공간을 가짐
재귀 부프로그램의 작성에 활용

-> 단점 : 미미하지만) 할당과 회수에 따른 실행-시간 부담
간접 주소지정 방식으로 접근하므로 정적 변수보다는 느림
부프로그램이 과거 데이터의 접근에 제약
CPU Time을 미미하게 잡아먹음

명시적 힙 동적 변수
프로그래머가 명시적으로 실행시간 명령어에 의해서 할당되고 회수되는 이름없는 메모리 셀
c언어 :프로그래머가 관리하지 않는 힙
-> 장점 : 리스트나 트리와 같이 실행시간에 동적으로 크기가 변하는 자료구조 구축

-> 단점 : 프로그래머가 사용하기 어려움, 7포인터와 참조 변수의 올바른 사용의 어려움
참조비용, 기억 공간 관리 구현의 복잡성 등

힙공간에 접근할 수 없는 공간이 많아지는 현상 -> memory leaking 메모리 누수

암묵접 힙 동적 변수 (파이썬, 자바스크립트)
값이 배정될 때 힙 기억 장소에 바인딩
값이 배정될 때마다 변수의 모든 속성이 바인딩 됨

장점 : 유연성과 일반화 프로그램 작성에 유리
단점 : 실행시간에 속성을 관리해야함으로 비용이 많이듬
컴파일러에 의한 오류 탐지 능력 상실

```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/15cd3e68-239a-4c61-b0e6-57718797d38c)
```
정적 변수, 스택, 힙이 각각 잡혔다가 사라지는 시간들이 각각 다르다.
main의 시작과 끝 안에 foo의 시작과 끝안에 malloc의 시작과 끝이 있다.
 free(pi) pi가 가리키는 공간 ->heap의 공간이 없어지는데 pi는 있음
```
```
참조 가능한 변수 <- 변수가 가시적이다.(visible)

영역 규칙 : 이름을 어느 변수와 연관을 짓게 할 것인가를 결정하는 규칙

지역 변수 vs 비지역 변수

지역 변수 : 블록 내에 선언된 변수
비지역 변수 : 프로그램이나 블록 내에는 선언되어 있지 않지만 해당 영역에서 가시적인 변수
전역 변수가 비지역 변수의 한 예
함수 안의 변수 밖의 전역 변수

정적 영역 : static rule이 정해져있음 실행시간에 앎 프로그래머가 프로그래밍 한 시점에 알 수 있다.

변수의 영역이 변수의 선언/위치 그리고 부프로그램들의 상호 간의 공간적 배치 관계에 의하여 결정 -> 실행을 안시켜봐도
프로그램을 보면 변수가 어디에 쓰였는 지, 함수와의 관계를 볼 때 결정할 수 있다.

정적 언어 : c, c++, java 변수의 영역을 실행 전에 알 수 있다. scoping rule은 실행전에 결정될 수 있음

두 가지 형태의 정적 영역 언어가 존재

함수 안에 함수를 생성할 수 있는 언어 -> Ada, JavaScript, Common LISP, Scheme, Python

가능하지 않는 언어 -> C기반 언어들 C, C++, JAVA
중첩은 허용치 않으나 중첩된 클래스 정의나 블록에 의해서 중첩된 정적 영역 생성 가능
함수 안에 블록을 넣어서 중첩된 정적 영역을 생성 가능하다.
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/92f75322-f2d5-4839-9299-2940a7f87356)
```
var변수나 함수를 hoisting

big(부모영역), sub1, sub2(자식영역)

nonlocal인 영역은 다른 영역(부모영역)
sub2의 영역에 x가 없을 때 자기 영역에서 찾는데 없음 -> 부모 영역(big 영역에서 x를 찾음 var x = 3;)
sub2의 y는 3이 찍힘

sub1은 7이 찍힘

big영역의 x는 7이 찍힘

지역 변수 > 외부변수
local > nonlocal

LEGB룰 로컬에서 찾고 Enclosed, global, built-in-> 없으면 NameError

sub1은 x = 3
sub2의 입장에서 sub2 enclosed x=2
rpint(X)마지막 입장에서 local은 x= 2
big() x=2

블록 : 변수의 참조 가능한 영역을 최소화하는 효과 <- 좁으면 좁을 수록 에러를 찾기 쉬움
블록 내에 생성된 영역은 스택과 동일 취급 블록에 진입될 때 확보됬다가 빠져나올 때 회수 <- 함수콜의 처리방식과 같다.
C,C++은 중첩된 함수를 허용하지 않음
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/30d87852-a9dc-4b94-a87f-bf40e8fea55e)
```
int x = 0; 은 데이터영역에
int x = 1 스택
int x = 2 스택 안의 스택에

지역우선 -> 블록에서나오면 스택에서 사라짐,-> x= 2 블록에 빠져나오고 -> x = 1; (3, 2, 1)

지역변수>전역변수인데 전역 쓰려면 c는 extern 키워드를 c++는 ::연산자를 사용한다.

java는 중첩 블록은 허용하지만 변수명이 중복되는 경우를 배제

js는 함수 블록은 제공 python은 블록기호가 없음
```
```
6.11 pointer와 reference type
11.1
11.2
11.3 pointer의 문제점들
11.4 c와 c++에 있는 포인터들
5 reference type
6
7

299p부터 311p까지 정리
위키피디아에서도 가능
```
```
#define은 C의 전처리기가 처리하는 것이지 C의 문법에서 처리하는 것이 아니다.
```
## 23.11.24
```
COBOL: 십진수 데이터 값의 정확도(accuracy)를 명세하는 것을 허용, 레코드 타입 제공
PL/I :정확도 명세 기능을 정수와 부동 소수점 타입으로 확장, 많은 데이터 타입을 소개
ALGOL 60 : 사용자 정의 타입 제공

타입이 언어의 각 식에 어떻게 연관되는지를 정의, 타입 동등성과 타입 호환성의 규칙을 포함
역할
1. 오류 탐지
2. 프로그램 모듈화를 위한 지원
3. 문서화
4. 프로그램에서 타입의 선언은 그 데이터에 관한 정보를 문서화 하는 것

구조화된 데이터 타입 : 명령형 언어에서 제공되는 구조화 데이터 타입 -> 배열과 레코드

기본 데이터 타입 : 기본 데이터 타입을 제공, 하드웨어 반영 정수, 실수
약간의 비하드웨어적 지원을 받는 기본 데이터 타입도 있을 수 있음

기본 데이터 타입은 구조화된 데이터 타입(배열, 구조체)를 제공하기 위해 활용

수치 타입 : 

십진수 데이터 타입 : 사무용 데이터 처리 -> 실수 타입에서 문제 

ASCII: 가장 공통적으로 사용되는 코딩
C언어에서 char 타입은 ASCII 코드를 저장
ISO 8859-1: 8비트 문자 코딩 기법으로 256개의 문자를 제공
Ada 95+는 ISO 8859-1을 사용
Unicode: 세상에 존재하는 대부분의 자연 언어에 속한 문자를 표현 -> Java, JavaScript, Python, Perl, C#, F# 등에 채용
대부분의 언어에서 단일 문자를 위한 타입을 제공
C의 char, JAVA의 char등

설계 고려사항 : c문자는 마지막문자가 공백으로 끝나는 문자들의 배열이 문자열이다.
다른건 기본타입으로 제공

문자열의 정적 길이 : 정해지면 변경x , 동적길이 :변경 가능
문자열 연산 

c: 조작함수가 안전하지 않음
c++ : c char말고 표준 라이브러리에 있는 string
java 는 string 클래스와 stringbuffer(동적) 컴파일시에 크기를 변경 가능 클래스에서 지원
string 클래스 객체는 immutable
stringbuffer 클래스 객체는 : mutable

python 문자열을 기본타입 immutable하다.
javascript,php,perl, ruby : 언어에 내장되어있어서 그냥 쓰면 된다.
F# : 유니코드 UTF-16으로 된 개개의 문자들
ML : 기본 데이터타입 IMMUTABLE

정적길이 : 문자열의 길이는 정적이고 문자열이 생성될 때 설정
제한된 동적길이 문자열, C의 문자열, C++에 사용하는 C스타일

동적 길이 문자열 : 제한된 길이 없이 가변길이를 갖는 것을 허용
Javascript, perl

ada 95+에서는 세가지를 모두 지원

c스타일의 문자열 지원 방식의 부자연스러움
문자열을 기본 타입에 포함시키는 것이 쉬워서 문자열은 기본 데이터타입으로 포함

순서 타입(ordinal type)
-기본 순서타입
-사용자 정의 순서타입 : 열거와 부분 범위 두가지

열거 타입(enumeration Type)
장점 : 간결해지고 가독성이 좋아진다.

설계 고려사항

*str1 = "Hello World" 4바이트의 공간이 있는데 그 이름이 str1이다.


4바이트 Hello World공간이 있다.

스택 : main에 대한 스택이 생긴다.
stringExam에 대한 스택이 생긴다.
함수의 로컬 변수가 생긴다. *str1이라는 이름의 공간을 가리킨다. 그 공간의 값은 HELLLO이다.
str2는 총 13바이트가 스택공간에 잡힌다. str2[] = "Hello World"
*str3 = NULL; NULL STR3이라는 이름의 공간을 가리킨다. 그 공간의 값은 NULL이다. 0번지
str4는 10바이트의 공간을 잡음 str4[10];
str5는 10바이트의 공간을 잡고 hello가 들어가 있음 6바이트가 들어가있고 4바이트는 비어있음
str5[10] = "hello"


printf null문자를 만날때까지 찍는다.
str1에 대한 strlen의 길이는

str2에 null을 넣을 수 없다. str2 배열 이름은 상수라서 readonly임
이후에 str2 = null을 넣을 수 없다.

malloc 힙에다가 공간을 잡아라 *str3 = malloc <- 힙영역을 가리키게하고
strcpy(str3, str1); str3에 str1 11바이트를 20바이트가 있는 곳에 넣어라 -> 충분히 들어감
힙영역에 그대로 복사하기 때문에 힙 영역에 hello 넣을 수 있음


str4에 str1을 넣는다면 str4의 크기는 10인데 str1 12바이트를 넣으면 오버플로우가 발생한다.
널이 없어지므로 str5는 d만 찍힘

str3는 free -> 메모리를 운영체제에 반납하겠다.
str3 = null -> null로 가리키도록 하겠다.

java

class loading < - c에서의 data나 text영역
stack <- c에서와 같음
heap <- c에서와의 차이는 managing heap이다. 필요하면 jvm이 알아서 메모리를 잡아주고
garbarge collector가 자동으로 반납

String msg = "HellO World" 모든 객체는 힙에 만들어진다. 따라서 msg의 hello world 객체는 힙에 만들어지고
msg가 hello world 객체를 가리킨다. 사이즈나 내용을 변경시키는 것이 불가능하다.

stringbuffer msg1이라는 참조변수가 hello world는 string buffer 객체는 사이즈나 내용을 변경시키는 것이 가능하다.

자바에서는 객체이기 때문에 자신에 대한 속성을 가지고 있다. hello world 객체의 길이가 msg에 저장되어 있다.
카운팅하는 개념이 아니고 따로따로 들어가 있다.

append를 사용하여 값의 내용을 변경시키는 것이 가능하다 . msg.append("korea") 붙이는거

python도 마찬가지로 msg1 = "Hello world" 라면 hello world는 힙에 존재한다

java, python는 힙에 객체가 만들어진다.

len이라는 내장함수를 호출한다. 슬라이스 연산 :5를 제공한다.

enum days { } 

enum gender { male =1, female =2 } gender 타입이 생기고 gender.male = 1
값을 따로 안주면 0이라는 값으로 ordinal() 수치값으로 접근하려면 gender.male.ordinal() 이렇게 접근해야
1

열거 타입의 타입을 int형처럼 취급해서 수치 연산이 불가능하다. 열거타입은 열거 타입일 뿐

스크립트 언어(python, javascript, ruby, php)들 중 열거 타입을 기본 타입으로 지원하는 것은 없다.
왜냐하면 표준 라이브러리로 제공한다.

열거형은 가독성과 신뢰성을 향상 시킨다.
산술연산을 허용하지 않는다. (열거형은 정수형이 아님)

정의된 범위 밖의 값을 할당 받을 수 없다.

C의 열거형은 열거 변수를 정수 변수 처럼 취급한다.
-> 가독성을 향상시키나 신뢰성의 면에서 문제를 야기할 수 있음

C++의 열거형은 비교연산에서 여전히 정수형 타입처럼 다루어 질 수 있다.

배열 타입 : 동질의 데이터 원소들의 연속된 데이터 모음
0부터 시작함 메모리가 0이라

배열 연산
배정, 접합, 비교, 슬라이스 등

C의 경우 배열 연산을 제공하지 않음 -> 라이브러리를 통해 필요한 기능 사용

Java, C++, C#은 배열이 객체로 제공되며 메소드로 수행

Python은 리스트 형태의 요소를 제공하며 이질적인 요소를 포함할 수 있음
배정, 접합(+), 원소 멤버쉽(in), 동일성 비교(is), 동등성 비교(==)

Fortran 95+는 elemental이라고 불리는 많은 배열 연산을 제공
배정, 산술, 관계, 논리, 행렬 곱셈, 행렬 전치, 벡터 내적에 대한 내장 함수나 라이브러리 제공 

APL에서는 배열 연산을 핵심요소로 제공공

이제까지 고안된 언어 중에서 가장 강력한 배열 처리 언어
언어의 난해성으로 후속 언어에 미친 영향이 없음

배열과 슬라이스
슬라이스는 배열의 어떤 부분 구조(substructure)이다.
Python, Ruby, Perl 등의 언어에서 배열의 슬라이스 연산을 제공 (slice.py 참조)

slice(2:5)
a:b:2 a부터 b까지 2의 간격으로 배열을 끊어라

모든 순서 타입을 첨자로 허용하거나 슬라이스 연산등의 진보가 있었음

immutable해야한다 hash를 사용하려면 immutable 변하기 쉽지 않아야 한다.

연상배열이면 해시함수를 사용해서 검색 등이 빠르다.
다만 키:값으로 키가 리스트면 mutable하다 값의 변경이 있을 수 있기 때문이다.

연상배열을 쓰면 좋은 점 : 가독성이 좋아진다.
```
## 23.12.01
```
정적 배열 : void main() 밖에 선언 -데이터영역
고정 스택-동적 배열 : 함수안에 선언
스택-동적 배열 : 함수 매개변수 t 가 A[t] 이렇게 되서 크기가 동적으로 변하는 것

스택은 런타임시에 컴파일러가 해줌

고정 힙-동적 배열 : 힙영역에 메모리를 할당했다가 반납하는 것
new로 생성 free로 반납, 스택보다는 느리다.

기억공간이 런타임시에 일어나야한다면 스택에 동적배열을 할당하는 것보다 힙에 할당하는 것이
기본적이다. (유연성)
힙-동적 배열 : 힙 영역에 기억공간의 할당이 동적으로 일어난다.
힙은 프로그래머가 해야함, C는 제공하지않고 리스트를 만들어서 구현한다. java에서는 제공된다.

배열 초기화 : int list[] = { 4, 5, 6, 7};

배열 연산 : C의 경우 라이브러리를 통해 필요한 기능을 사용한다.
C++,java는 배열이 객체로 제공되어 메소드를 이용해서 구현
python은 리스트 형태의 요소를 제공 이질적인 요소를 포함할 수 있다.

기본배열은 첨자로 연상 배열은 키값으로 인덱싱, 순서를 갖지않음
C는 연상배열없음 

python 키:값 키는 hashable = immutable 한값  변함없는 값이어야 함
perl key는 문자열만 가능
php 키가 정수 혹은 문자열이 가능
java map으로 불린다. 표준라이브러리에서 제공

연상배열의 장점을 배열과 비교하여 서술하라.
연상배열은 가독성과 작성력을 높인다. 원소들의 접근에 있어서 속도가 빠르다.
하지만 모든 요소들을 하나씩 처리해야 하는 경우 배열이 효율적이다.
```

```
레코드 타입 : 개개의 요소들이 이름으로 식별되고, 그 구조의 시작부터 오프셋을 통해
접근되는 데이터 원소들의 집합

개개의 원소들이 동일한 타입이나 크기가 아닌 데이터의 모임을 모델링할 때 빈번하게 사용

C,C++,C#에서 레코드 타입은 struct 데이터 타입으로 지원
c++, c#의 구조체는 캡슐구조체로서 사용
Java, C#에서 레코드는 데이터 클래스로서 정의

순서를 고려하지 않는다. 필드로 접근

전역변수는 데이터영역에 20바이트로잡힘
지역변수는 main이라는 스택에 만들어짐

힙에 레코드를 만들려면
Struct student *kim
kim = (Struct Student*)malloc(sizeof(struct Student);
(*kim).name = "Kim DukBae"; <-초기화

kim->name

튜플은 배열과 유사하나 배열은 동질적인 요소들, 튜플은 이질적인 요소들로 이루어짐
요소의 접근시 배열과 마찬가지로 첨자를 사용한다.

리스트는 값의 변화가 가능하다.mutable하다
튜플은 값의 변화가 불가능하다.immutable

C#, Java에서는 List와 ArrayList를 제공
리스트 요소들은 첨자에 의해서 참조

튜플은 immutable하지만 리스트는 mutable함 변경가능하다.

리스트의 요소를 del로 삭제 가능

배열 int a[5] = {1, 2, 3, 4, 5}
레코드 struct a[5] = {1, "abc", 3}
튜플 a = (1, 2, 3,"graph")
리스트 a = [1, 2, 3, "graph"]

Python List Comprehension
리스트 집합 표기법을 제공 [x for x for in range(1,101)] -> 1, 2, 3, 4 ~ 101
[2* x for x in range(1,101)] -> 2, 4, 6 ,8 ~ 100
set Comprehension { } 집합 기호도 가능

구조체의 크기는 8바이트 단위로 잡는다 따로'따로

인텔은 리틀엔디안 -> 왼쪽에서부터 읽음
네트워크 프로그래밍 => 빅엔디안 

공용체 타입 공용체는 최고 큰 크기로 잡고 모든 요소가 그 크기를 사용한다.
공용으로 사용한다. low-level 시스템 프로그래밍, 네트워크 프로그래밍에 공용체를 사용한다.
그 이유는 high level과 다르게 시스템이 어떤 엔디안을 따르는지 고려해야 하기 때문이다.
low-level에 있는 것들에 있는 각각 다른 여러바이트를 관리하기에 공용체를 사용하는 것이 좋다.
한 덩어리를 잡아놓고 전체를 가져올것인지 부분을 나눠서 부분을 가져올 것인지

union Edian {
 int i;
 char ch[4];
 short low;
};

ch[0], ch[1], ch[2], ch[3] -> 4바이트
ch[0] => 78
ch[1] => 56
ch[2] => 34
ch[3] => 12
short->2바이트 사용

union Endian value;
value.i = 0x12345678;
printf(value.i) -> 78 56 34 12
print(value.ch[0] -> 78
print(value.short) -> 5678


들어갈 때 반대로 들어감 리틀엔디안 low level

타입 검사를 하지 않는 공용체 C, C++ 
union 키워드는 union 구조체를 명세하는 데 사용

타입체킹을 하는 공용체 판별 공용체 -> Ada, Algo, ML, Haskell

공용체가 없음 안전상의 문제가 있을 수 있기 때문에 java, C#

포인터의 참조 타입

가상 메모리 프로그래머에게 메모리공간이 있다라고 부여해주는 공간
실 메모리는 뒤에 있다. 1GB

간접 주소지정 방식을 지원하기 위해
동적 기억공간(힙 heap)을 관리하는 방식을 제공하기 위해

힙-동적 변수
힙공간에 동적으로 할당되는 변수
식별자(이름)가 없음 -> 무명 변수
따라서 포인터를 이용하여 간접적으로 접근이 가능

포인터는 동적 자료구조의 작성력을 향상시킴


```














